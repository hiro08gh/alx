use crate::alias::Alias;
use crate::error::Result;
use crate::shell::{ShellHandler, ShellType};
use std::path::PathBuf;

pub struct BashHandler;

impl BashHandler {
    pub fn new() -> Self {
        Self
    }

    fn escape_command(command: &str) -> String {
        // Escape single quotes in command
        command.replace('\'', r"'\''")
    }
}

impl ShellHandler for BashHandler {
    fn shell_type(&self) -> ShellType {
        ShellType::Bash
    }

    fn generate_alias_line(&self, alias: &Alias) -> String {
        let escaped_command = Self::escape_command(&alias.command);
        format!("alias {}='{}'", alias.name, escaped_command)
    }

    fn generate_aliases_file(&self, aliases: &[&Alias]) -> String {
        let mut content = String::new();
        content.push_str("# Generated by alx - DO NOT EDIT MANUALLY\n");
        content.push_str("# This file is automatically generated and will be overwritten\n\n");

        if aliases.is_empty() {
            content.push_str("# No aliases configured\n");
            return content;
        }

        // Group by category
        let mut grouped: std::collections::HashMap<String, Vec<&Alias>> =
            std::collections::HashMap::new();

        for alias in aliases {
            let group = alias.group.as_deref().unwrap_or("general");
            grouped.entry(group.to_string()).or_default().push(alias);
        }

        let mut groups: Vec<_> = grouped.keys().collect();
        groups.sort();

        for group in groups {
            let group_aliases = grouped.get(group).unwrap();
            content.push_str(&format!("# {} aliases\n", group));

            for alias in group_aliases {
                if let Some(desc) = &alias.description {
                    content.push_str(&format!("# {}\n", desc));
                }
                content.push_str(&format!("{}\n", self.generate_alias_line(alias)));
            }
            content.push('\n');
        }

        content
    }

    fn config_file_path(&self) -> Result<PathBuf> {
        let home = dirs::home_dir().ok_or_else(|| {
            crate::error::AlxError::ConfigError("Could not find home directory".to_string())
        })?;
        Ok(home.join(".bashrc"))
    }
}

impl Default for BashHandler {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_alias_line() {
        let handler = BashHandler::new();
        let alias = Alias::new("ll".to_string(), "ls -la".to_string());

        let line = handler.generate_alias_line(&alias);
        assert_eq!(line, "alias ll='ls -la'");
    }

    #[test]
    fn test_escape_command() {
        let handler = BashHandler::new();
        let alias = Alias::new("test".to_string(), "echo 'hello'".to_string());

        let line = handler.generate_alias_line(&alias);
        assert_eq!(line, "alias test='echo '\\''hello'\\'''");
    }

    #[test]
    fn test_generate_aliases_file() {
        let handler = BashHandler::new();
        let alias1 = Alias::new("ll".to_string(), "ls -la".to_string())
            .with_description("List all files".to_string())
            .with_group("general".to_string());
        let alias2 =
            Alias::new("gs".to_string(), "git status".to_string()).with_group("git".to_string());

        let aliases = vec![&alias1, &alias2];
        let content = handler.generate_aliases_file(&aliases);

        assert!(content.contains("alias ll='ls -la'"));
        assert!(content.contains("alias gs='git status'"));
        assert!(content.contains("# List all files"));
    }
}
