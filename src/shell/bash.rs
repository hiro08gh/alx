use crate::alias::Alias;
use crate::error::Result;
use crate::shell::ShellHandler;
use std::path::PathBuf;

pub struct BashHandler;

impl BashHandler {
    pub fn new() -> Self {
        Self
    }

    fn escape_command(command: &str) -> String {
        // Escape single quotes in command
        command.replace('\'', r"'\''")
    }
}

impl ShellHandler for BashHandler {
    fn generate_alias_line(&self, alias: &Alias) -> String {
        let escaped_command = Self::escape_command(&alias.command);
        format!("alias {}='{}'", alias.name, escaped_command)
    }

    fn generate_aliases_file(&self, aliases: &[&Alias]) -> String {
        let mut content = String::new();
        content.push_str("# Generated by alx - DO NOT EDIT MANUALLY\n");
        content.push_str("# This file is automatically generated and will be overwritten\n\n");

        if aliases.is_empty() {
            content.push_str("# No aliases configured\n");
            return content;
        }

        // Group by category
        let mut grouped: std::collections::HashMap<String, Vec<&Alias>> =
            std::collections::HashMap::new();

        for alias in aliases {
            let group = alias.group.as_deref().unwrap_or("general");
            grouped.entry(group.to_string()).or_default().push(alias);
        }

        let mut groups: Vec<_> = grouped.keys().collect();
        groups.sort();

        for group in groups {
            let group_aliases = grouped.get(group).unwrap();
            content.push_str(&format!("# {} aliases\n", group));

            for alias in group_aliases {
                if let Some(desc) = &alias.description {
                    content.push_str(&format!("# {}\n", desc));
                }
                content.push_str(&format!("{}\n", self.generate_alias_line(alias)));
            }
            content.push('\n');
        }

        content
    }

    fn config_file_path(&self) -> Result<PathBuf> {
        let home = dirs::home_dir().ok_or_else(|| {
            crate::error::AlxError::ConfigError("Could not find home directory".to_string())
        })?;
        Ok(home.join(".bashrc"))
    }

    fn parse_aliases_from_file(&self, path: &std::path::Path) -> Result<Vec<(String, String)>> {
        use std::fs;

        let content = fs::read_to_string(path)?;
        let mut aliases = Vec::new();
        let mut current_line = String::new();

        for line in content.lines() {
            let trimmed = line.trim();

            // Handle line continuation
            if current_line.is_empty() {
                current_line = trimmed.to_string();
            } else {
                current_line.push(' ');
                current_line.push_str(trimmed);
            }

            // Check if line continues
            if current_line.ends_with('\\') {
                current_line.pop(); // Remove backslash
                continue;
            }

            // Parse alias from the complete line
            if let Some(alias) = Self::parse_alias_line(&current_line) {
                aliases.push(alias);
            }

            current_line.clear();
        }

        Ok(aliases)
    }
}

impl BashHandler {
    fn parse_alias_line(line: &str) -> Option<(String, String)> {
        let trimmed = line.trim();

        // Skip comments and empty lines
        if trimmed.is_empty() || trimmed.starts_with('#') {
            return None;
        }

        // Check if line starts with 'alias '
        if !trimmed.starts_with("alias ") {
            return None;
        }

        // Remove 'alias ' prefix
        let alias_def = trimmed.strip_prefix("alias ")?.trim();

        // Find the '=' separator
        let equals_pos = alias_def.find('=')?;
        let name = alias_def[..equals_pos].trim().to_string();
        let value_part = alias_def[equals_pos + 1..].trim();

        // Remove quotes (single or double)
        let command = if (value_part.starts_with('\'') && value_part.ends_with('\''))
            || (value_part.starts_with('"') && value_part.ends_with('"'))
        {
            value_part[1..value_part.len() - 1].to_string()
        } else {
            value_part.to_string()
        };

        Some((name, command))
    }
}

impl Default for BashHandler {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;

    #[test]
    fn test_generate_alias_line() {
        let handler = BashHandler::new();
        let alias = Alias::new("ll".to_string(), "ls -la".to_string());

        let line = handler.generate_alias_line(&alias);
        assert_eq!(line, "alias ll='ls -la'");
    }

    #[test]
    fn test_escape_command() {
        let handler = BashHandler::new();
        let alias = Alias::new("test".to_string(), "echo 'hello'".to_string());

        let line = handler.generate_alias_line(&alias);
        assert_eq!(line, "alias test='echo '\\''hello'\\'''");
    }

    #[test]
    fn test_generate_aliases_file() {
        let handler = BashHandler::new();
        let alias1 = Alias::new("ll".to_string(), "ls -la".to_string())
            .with_description("List all files".to_string())
            .with_group("general".to_string());
        let alias2 =
            Alias::new("gs".to_string(), "git status".to_string()).with_group("git".to_string());

        let aliases = vec![&alias1, &alias2];
        let content = handler.generate_aliases_file(&aliases);

        assert!(content.contains("alias ll='ls -la'"));
        assert!(content.contains("alias gs='git status'"));
        assert!(content.contains("# List all files"));
    }

    #[test]
    fn test_parse_aliases_from_file() {
        let handler = BashHandler::new();
        let temp_dir = tempfile::tempdir().unwrap();
        let file_path = temp_dir.path().join(".bashrc");

        let content = r#"
# Some comment
alias ll='ls -la'
alias gs="git status"
alias gp='git push'

# Multi-line alias
alias complex='echo "hello" && \
  echo "world"'

# Not an alias
export PATH=$PATH:/usr/local/bin
"#;

        let mut file = std::fs::File::create(&file_path).unwrap();
        file.write_all(content.as_bytes()).unwrap();

        let aliases = handler.parse_aliases_from_file(&file_path).unwrap();

        assert_eq!(aliases.len(), 4);
        assert!(aliases.contains(&("ll".to_string(), "ls -la".to_string())));
        assert!(aliases.contains(&("gs".to_string(), "git status".to_string())));
        assert!(aliases.contains(&("gp".to_string(), "git push".to_string())));
        assert!(aliases.iter().any(|(name, _)| name == "complex"));
    }

    #[test]
    fn test_parse_aliases_empty_file() {
        let handler = BashHandler::new();
        let temp_dir = tempfile::tempdir().unwrap();
        let file_path = temp_dir.path().join(".bashrc");

        let mut file = std::fs::File::create(&file_path).unwrap();
        file.write_all(b"# Just comments\n").unwrap();

        let aliases = handler.parse_aliases_from_file(&file_path).unwrap();

        assert_eq!(aliases.len(), 0);
    }
}
